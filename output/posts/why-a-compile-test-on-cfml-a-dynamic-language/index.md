---
title: "Why a compile test on CFML, a dynamic language?"
date: 2011-12-16
categories: 
  - "ColdFusion"
  - "mxunit"
---

"[Building a bridge for unit testing and ci in cfml](/building-a-bridge-for-unit-testing-ci-in-cfml)" had great comments by [Sean Corfield](http://corfield.org/). One was when he asked "why (do) you want a \_compile\_ step in there (your ci process) at all?" It comes back to an old Hanselminute podcast "[Dynamic vs compiled languages](http://hanselminutes.com/29/dynamic-vs-compiled-languages)". The show talks about how programmers had a _safety net_ when using a compiled language, **the compiler**. If the compiler passed, the program was 98% good except for some odd error. With Dynamic languages _the safety net was discarded_ and nothing was there to take its place thus unit testing was introduced to take the compiler's place. Even in a dynamic language the compiler still is **useful to catch syntax errors**. The podcast mentions to think of the compile tests on a dynamic language as the _smallest unit test possible_. Now take CFML and CI - for a simple indicator if your code base will work at the **most basic level is the compile test**. You can setup CI, _add the compile test and have a measurable test_ for your manager and other developers. It gives immediate feedback on if the code works. You don't have to learn MXUNIT, learn how to create a build process, learn how to write testable code, etc. Sean mentions setting up MXUnit via Hudson worked out of the box. That is great but **what value does it give management or the developer** after setup up without investing resources to learn MXUnit, create a test, create more tests, refactor code so it is testable, create new code so it is testable, etc. This is daunting and time intensive. Adding a compile test gives feedback on the whole project without more cost. Sean also comments "I'm very surprised to hear you say setting up CI is complex and takes time. What aspects of it do you find complex?" I think it is the process as a whole. _Without meaningful intermediate steps_, the process is daunting. If it wasn't, more CFML shops would be using CI and Unit testing. My personal experience was setting up Jenkins with Git on Windows. It had some hurdles with configuring permissions, windows mappings, and path executibles. I have Jenkins and Git work together but we are in no position to start writing unit tests for multiple reasons from code base, management sign off, and (you fill in the blank). This is where a compile test would come into place. It would give me, management, and developers feedback from CI without investing more time. Back to what I am finding complex. Another huddle, is automating the build process. Instead of _tackling this in all one step_ with CI and unit testing the intermidiate step for me is a compile test. I am not proposing the **compile test as the end solution but a bridge** to more compresensive CI and Unit testing for average CFML shops.

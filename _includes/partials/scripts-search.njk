<!-- Search functionality scripts -->
<script src="{{ '/pagefind/pagefind-ui.js' | url }}" type="text/javascript" defer></script>
<script>
    window.addEventListener('DOMContentLoaded', (event) => {
        // SEARCH CONFIGURATION CONSTANTS
        const SEARCH_CONFIG = {
            DEBOUNCE_MS: 200,
            EXCERPT_LENGTH: 200,
            PAGE_SIZE: 8,
            RESULT_PROCESSING_DELAY: 250,
            INIT_DELAY: 200
        };

        // Enhanced error handling wrapper
        function withErrorHandling(fn, context = '') {
            return function(...args) {
                try {
                    return fn.apply(this, args);
                } catch (error) {
                    console.error(`Error in ${context}:`, error);
                    // Announce error to screen readers
                    const announcement = document.getElementById('sr-announcements');
                    if (announcement) {
                        announcement.textContent = `Search error: ${error.message}`;
                    }
                    return null;
                }
            };
        }

        // Function to extract categories from search results
        function extractCategories(result) {
            // First try to get categories from Pagefind metadata
            const metaData = result.data?.meta;
            if (metaData && metaData.categories) {
                // If categories is a string, split it; if array, use as-is
                return typeof metaData.categories === 'string' 
                    ? metaData.categories.split(',').map(cat => cat.trim())
                    : metaData.categories;
            }
            
            // Try to extract categories from the beginning of the excerpt text
            const excerptElement = result.querySelector('.pagefind-ui__result-excerpt');
            if (excerptElement) {
                const excerptText = excerptElement.textContent.trim();
                
                // Look for category pattern at the beginning of excerpt
                // Categories are usually single words or short phrases before the main content
                const words = excerptText.split(/\s+/);
                const categories = [];
                
                // Take words from the beginning that look like categories (short, capitalized, etc.)
                for (let i = 0; i < Math.min(words.length, 6); i++) {
                    const word = words[i];
                    
                    // Stop if we hit common starting words for actual content
                    if (/^(here|this|the|a|an|in|on|at|for|with|by|from|to|of|and|or|but|if|when|where|how|what|why|who|i|you|we|they|he|she|it)$/i.test(word)) {
                        break;
                    }
                    
                    // Stop if word contains punctuation (likely start of sentence)
                    if (/[.!?:;,]/.test(word)) {
                        break;
                    }
                    
                    // Add word as potential category if it's not too long
                    if (word.length <= 20 && word.length >= 2) {
                        categories.push(word);
                    } else {
                        break;
                    }
                }
                
                if (categories.length > 0) {
                    return categories;
                }
            }
            
            // Fallback: look for category tags in the result HTML
            const categoryTags = result.querySelectorAll('.category-tag');
            if (categoryTags.length > 0) {
                return Array.from(categoryTags).map(tag => tag.textContent.trim());
            }
            
            // Last resort: try to find in pagefind result tags
            const resultTags = result.querySelectorAll('.pagefind-ui__result-tag');
            const categories = [];
            resultTags.forEach(tag => {
                const text = tag.textContent;
                // Look for category-like metadata
                if (text.includes('Category:') || text.includes('Categories:')) {
                    const categoryMatch = text.match(/Categories?:\s*(.+)/i);
                    if (categoryMatch) {
                        categories.push(...categoryMatch[1].split(',').map(cat => cat.trim()));
                    }
                }
            });
            
            return categories;
        }

        // Simple function to create category tags HTML
        function createCategoryTags(categories) {
            if (!categories || categories.length === 0) return '';
            
            // No base path needed since we're on the main domain now
            const basePath = '';
            
            const categoryHTML = categories.map(category => {
                const slug = category.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
                return `<a href="${basePath}/category/${slug}/" class="category-tag">${category}</a>`;
            }).join('');
            
            return `<div class="blog-post-categories">${categoryHTML}</div>`;
        }

        // Simple function to clean excerpt text - matches server-side blogExcerpt filter exactly
        function cleanExcerpt(text, categories = []) {
            if (!text) return '';
            
            let cleanContent = text;
            
            // First, remove categories from the beginning if they were extracted
            if (categories.length > 0) {
                // Create a pattern that matches all categories at the start
                const categoryWords = categories.map(cat => cat.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'));
                
                // Try to remove all categories as a group first
                const allCategoriesPattern = new RegExp(`^${categoryWords.join('\\s+')}\\s*\\.?\\s*`, 'i');
                cleanContent = cleanContent.replace(allCategoriesPattern, '');
                
                // If that didn't work, remove each category individually from the start
                categoryWords.forEach(escapedCategory => {
                    const individualRegex = new RegExp(`^${escapedCategory}\\s*\\.?\\s*`, 'i');
                    cleanContent = cleanContent.replace(individualRegex, '');
                });
            }
            
            // Remove "Published on [date]" pattern from the beginning
            cleanContent = cleanContent.replace(/^.*?Published on.*?\d{4}\.?\s*/i, '');
            
            // Now apply the same cleaning as server-side blogExcerpt filter
            cleanContent = cleanContent
                // Remove [code] blocks that haven't been processed yet
                .replace(/\[code[^\]]*\][\s\S]*?\[\/code\]/gi, ' ')
                // Remove generated code block HTML
                .replace(/<div class="code-block">[\s\S]*?<\/div>/gi, ' ')
                // Remove any remaining [code] orphan tags
                .replace(/\[(?:\/)?code[^\]]*\]/gi, ' ')
                // Remove HTML tags
                .replace(/<[^>]*>/g, ' ')
                // Decode HTML entities
                .replace(/&quot;/g, '"')
                .replace(/&#39;/g, "'")
                .replace(/&apos;/g, "'")
                .replace(/&lt;/g, '<')
                .replace(/&gt;/g, '>')
                .replace(/&amp;/g, '&') // Keep this last to avoid double-decoding
                // Clean up whitespace
                .replace(/\s+/g, ' ')
                .trim();

            // Truncate to specified length (match server-side logic exactly)
            const length = 300; // Match server-side default length
            if (cleanContent.length > length) {
                // Find the last complete word within the length limit
                const truncated = cleanContent.substring(0, length);
                const lastSpace = truncated.lastIndexOf(' ');

                if (lastSpace > length * 0.8) {
                    // If we found a space reasonably close to the end (match server-side threshold)
                    return truncated.substring(0, lastSpace) + '...';
                } else {
                    return truncated + '...';
                }
            }

            return cleanContent;
        }

        // Simple function to process search results with consistent animations
        function processSearchResults(searchResults = null) {
            const allResults = document.querySelectorAll('.pagefind-ui__result');
            const results = Array.from(allResults).filter(result => !result.hasAttribute('data-enhanced'));
            
            results.forEach((result, index) => {
                const titleElement = result.querySelector('.pagefind-ui__result-title');
                const excerptElement = result.querySelector('.pagefind-ui__result-excerpt');
                const linkElement = result.querySelector('.pagefind-ui__result-link');
                
                if (!titleElement || !linkElement) return;
                
                const href = linkElement.href.replace(/http:\/\/localhost:\d+/, '');
                
                // Check if this is a blog post by looking for categories metadata or URL patterns
                // Since blog posts are now at root level, we need a different detection method
                const isBlogPost = (
                    // Check if result has category metadata (blog posts have categories)
                    result.textContent.includes('Categories:') ||
                    result.querySelector('.pagefind-ui__result-tag')?.textContent.includes('Categories:') ||
                    // Check for typical blog post URL patterns (not /search/, /category/, etc.)
                    (!href.includes('/search/') && !href.includes('/category/') && 
                     href !== '/' && href.match(/^\/[^\/]+\/$/) && !href.includes('/pages/'))
                );
                
                if (isBlogPost) {
                    // Transform the result to look like a blog card
                    result.classList.add('blog-post-card');
                    
                    // Get the original title text and link
                    const originalTitle = titleElement.textContent;
                    const originalLink = linkElement.href;
                    
                    // Replace title element content but keep the element
                    titleElement.tagName = 'H2'; // This won't work, we need to replace the element
                    
                    // Create new h2 element to replace the title
                    const newTitle = document.createElement('h2');
                    newTitle.className = 'blog-post-title';
                    newTitle.innerHTML = `<a href="${href}">${originalTitle}</a>`;
                    
                    // Replace the original title element
                    titleElement.parentNode.replaceChild(newTitle, titleElement);
                    
                    // Add categories after title
                    const categories = extractCategories(result);
                    if (categories.length > 0) {
                        const categoryDiv = document.createElement('div');
                        categoryDiv.className = 'blog-post-categories';
                        
                        // No base path needed since we're on the main domain now
                        const basePath = '';
                        
                        // Create category links individually to ensure proper attributes
                        categories.forEach(category => {
                            const categoryLink = document.createElement('a');
                            const slug = category.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
                            categoryLink.href = `${basePath}/category/${slug}/`;
                            categoryLink.className = 'category-tag';
                            categoryLink.textContent = category;
                            categoryDiv.appendChild(categoryLink);
                        });
                        
                        newTitle.insertAdjacentElement('afterend', categoryDiv);
                    }
                    
                    // Clean and replace excerpt content
                    if (excerptElement) {
                        const originalExcerpt = excerptElement.textContent;
                        const cleanedExcerpt = cleanExcerpt(originalExcerpt, categories);
                        excerptElement.className = 'blog-post-excerpt';
                        excerptElement.innerHTML = cleanedExcerpt;
                    }
                    
                    // Add publish date (extract from original excerpt text if available)
                    const dateMatch = result.textContent.match(/(\w+ \d{1,2}, \d{4})/);
                    if (dateMatch) {
                        const dateElement = document.createElement('p');
                        dateElement.className = 'blog-post-date';
                        dateElement.innerHTML = `<em>Published on <time datetime="${new Date(dateMatch[1]).toISOString().split('T')[0]}" data-pagefind-meta="date">${dateMatch[1]}</time></em>`;
                        result.appendChild(dateElement);
                    }
                }
                
                result.setAttribute('data-enhanced', 'true');
            });
            
            // Animate the entire result containers (not just the blog cards inside)
            setTimeout(() => {
                const resultContainers = document.querySelectorAll('.pagefind-ui__result');
                resultContainers.forEach((container, index) => {
                    setTimeout(() => {
                        container.classList.add('animate');
                    }, 50 + (index * 100)); // Stagger the animations
                });
            }, 50);
        }

        // Initialize Pagefind Search if search element exists
        if (document.getElementById("search")) {
            try {
                // Auto-detect bundle path or use explicit path
                const bundlePath = window.location.pathname.includes('/search/') ? '../pagefind/' : '/pagefind/';
                
                const searchConfig = { 
                    element: "#search", 
                    showSubResults: true,
                    showEmptyFilters: false,
                    resetStyles: false,
                    autofocus: window.location.pathname.includes('/search/'),
                    debounceTimeoutMs: 0, // Disable built-in debouncing since we handle it
                    bundlePath: bundlePath,
                    excerptLength: 200,
                    pageSize: 8,
                    showImages: false,
                    processResult: function(result) {
                        // All results are processed the same way now
                        return result;
                    },
                    translations: {
                        placeholder: "Search articles, posts, and pages...",
                        clear_search: "Clear",
                        load_more: "Load more results",
                        search_label: "Search this site",
                        filters_label: "Filters",
                        zero_results: "",  // Disable default messages
                        many_results: "",  // We'll handle these ourselves
                        one_result: "",    // To prevent flash
                        alt_search: "",
                        search_suggestion: "",
                        searching: ""      // Disable default searching message
                    }
                };

                // Add custom result template for search page
                if (window.location.pathname.includes('/search/')) {
                    searchConfig.showImages = false;
                    searchConfig.showSubResults = true;
                    searchConfig.excerptLength = 80;
                    searchConfig.pageSize = 10;
                }
                
                const pagefindUI = new PagefindUI(searchConfig);
                
                // Simplified search processing with reliable message control
                const searchElement = document.getElementById("search");
                if (searchElement) {
                    let debounceTimer = null;
                    
                    const setMessage = (text) => {
                        const message = document.querySelector('.pagefind-ui__message');
                        if (message) {
                            message.textContent = text;
                            message.style.visibility = text ? 'visible' : 'hidden';
                        }
                    };
                    
                    const updateFinalMessage = (searchTerm) => {
                        const results = document.querySelectorAll('.pagefind-ui__result');
                        if (searchTerm && results.length > 0) {
                            const count = results.length;
                            const resultText = count === 1 ? 'result' : 'results';
                            setMessage(`${count} ${resultText} for "${searchTerm}"`);
                        } else if (searchTerm) {
                            setMessage(`No results found for "${searchTerm}"`);
                        } else {
                            setMessage('');
                        }
                    };
                    
                    // Monitor for search input changes
                    const observer = new MutationObserver(() => {
                        const searchInput = searchElement.querySelector('input[type="search"]');
                        if (searchInput && !searchInput.hasAttribute('data-processed')) {
                            searchInput.setAttribute('data-processed', 'true');
                            
                            searchInput.addEventListener('input', () => {
                                const searchTerm = searchInput.value.trim();
                                
                                // Clear any existing timer
                                if (debounceTimer) {
                                    clearTimeout(debounceTimer);
                                }
                                
                                // Show searching state immediately
                                if (searchTerm) {
                                    setMessage('Searching...');
                                } else {
                                    setMessage('');
                                }
                                
                                // Debounced processing
                                debounceTimer = setTimeout(() => {
                                    processSearchResults();
                                    updateFinalMessage(searchTerm);
                                }, 400);
                            });
                        }
                    });
                    
                    observer.observe(searchElement, { childList: true, subtree: true });
                    
                    // Initial setup if input already exists
                    setTimeout(() => {
                        const searchInput = searchElement.querySelector('input[type="search"]');
                        if (searchInput && !searchInput.hasAttribute('data-processed')) {
                            searchInput.setAttribute('data-processed', 'true');
                            
                            searchInput.addEventListener('input', () => {
                                const searchTerm = searchInput.value.trim();
                                
                                if (debounceTimer) {
                                    clearTimeout(debounceTimer);
                                }
                                
                                if (searchTerm) {
                                    setMessage('Searching...');
                                } else {
                                    setMessage('');
                                }
                                
                                debounceTimer = setTimeout(() => {
                                    processSearchResults();
                                    updateFinalMessage(searchTerm);
                                }, 400);
                            });
                        }
                    }, 100);
                    
                    // Process any existing results
                    setTimeout(() => processSearchResults(), 200);
                }
                
                console.log('PagefindUI initialized successfully');
            } catch (error) {
                console.error('Failed to initialize PagefindUI:', error);
            }
        }

        // Enhanced Search Keyboard Shortcuts and Accessibility
        document.addEventListener('keydown', function(event) {
            // Ctrl/Cmd + K to focus search
            if ((event.ctrlKey || event.metaKey) && event.key === 'k') {
                event.preventDefault();
                const searchInput = document.querySelector('.pagefind-ui__search-input');
                if (searchInput) {
                    searchInput.focus();
                    searchInput.select();
                }
            }
            
            // Escape to clear search when input is focused
            if (event.key === 'Escape') {
                const searchInput = document.querySelector('.pagefind-ui__search-input');
                if (searchInput && document.activeElement === searchInput) {
                    searchInput.value = '';
                    searchInput.dispatchEvent(new Event('input', { bubbles: true }));
                }
            }
        });
        
        // Add search shortcut hint
        const searchInput = document.querySelector('.pagefind-ui__search-input');
        if (searchInput && window.location.pathname.includes('/search/')) {
            searchInput.setAttribute('title', 'Use Ctrl+K to focus search, Escape to clear');
            
            // Add subtle hint after the search loads
            setTimeout(() => {
                const searchContainer = document.getElementById('search');
                if (searchContainer && !searchContainer.querySelector('.search-hint')) {
                    const hint = document.createElement('p');
                    hint.className = 'search-hint';
                    hint.style.cssText = `
                        text-align: center; 
                        color: var(--color-text-secondary); 
                        font-size: var(--font-size-xs); 
                        margin-top: var(--spacing-sm);
                        opacity: 0.7;
                    `;
                    hint.innerHTML = '<kbd style="background: var(--color-surface-light); padding: 2px 6px; border-radius: 3px; font-size: 11px;">Ctrl+K</kbd> to focus • <kbd style="background: var(--color-surface-light); padding: 2px 6px; border-radius: 3px; font-size: 11px;">Esc</kbd> to clear';
                    searchContainer.appendChild(hint);
                }
            }, 1000);
        }
    });
</script>

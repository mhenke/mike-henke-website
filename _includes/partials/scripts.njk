<!-- Shared JavaScript for all layouts -->
<script src="{{ '/pagefind/pagefind-ui.js' | url }}" type="text/javascript" defer></script>
<script>
    window.addEventListener('DOMContentLoaded', (event) => {
        // New Mobile Navigation Toggle
        const navToggle = document.querySelector('.navbar-toggle');
        const navLinks = document.querySelector('.navbar-links');
        const navOverlay = document.querySelector('.nav-overlay');
        const menuClose = document.querySelector('.menu-close');
        
        if (navToggle && navLinks) {
            // Store scroll position for restoration
            let scrollPosition = 0;

            function openMobileMenu() {
                scrollPosition = window.pageYOffset;
                navToggle.setAttribute('aria-expanded', 'true');
                navLinks.classList.add('active');
                navToggle.classList.add('active');
                if (navOverlay) {
                    navOverlay.classList.add('active');
                }
                document.body.classList.add('nav-open');
                document.body.style.top = `-${scrollPosition}px`;
            }

            function closeMobileMenu() {
                navLinks.classList.remove('active');
                navToggle.classList.remove('active');
                navToggle.setAttribute('aria-expanded', 'false');
                if (navOverlay) {
                    navOverlay.classList.remove('active');
                }
                document.body.classList.remove('nav-open');
                document.body.style.top = '';
                if (scrollPosition) {
                    window.scrollTo(0, scrollPosition);
                    scrollPosition = 0;
                }
            }

            // Hamburger menu toggle
            navToggle.addEventListener('click', () => {
                const isExpanded = navToggle.getAttribute('aria-expanded') === 'true';
                
                if (!isExpanded) {
                    openMobileMenu();
                } else {
                    closeMobileMenu();
                }
            });

            // Close button in mobile menu
            if (menuClose) {
                menuClose.addEventListener('click', () => {
                    closeMobileMenu();
                });
            }

            // Close mobile menu when clicking on a nav link
            const navLinkItems = navLinks.querySelectorAll('a');
            navLinkItems.forEach(link => {
                link.addEventListener('click', () => {
                    if (window.innerWidth < 768) {
                        closeMobileMenu();
                    }
                });
            });

            // Close mobile menu when clicking on overlay
            if (navOverlay) {
                navOverlay.addEventListener('click', () => {
                    closeMobileMenu();
                });
            }

            // Close mobile menu when pressing Escape key
            document.addEventListener('keydown', (event) => {
                if (event.key === 'Escape' && navLinks.classList.contains('active')) {
                    closeMobileMenu();
                }
            });

            // Handle window resize - close mobile menu if switching to desktop
            window.addEventListener('resize', () => {
                if (window.innerWidth >= 768) {
                    closeMobileMenu();
                }
            });
        }

        // Shared function to generate blog excerpt HTML structure - matches blog-excerpt.njk macro
        function generateBlogExcerptHTML(excerpt) {
            if (!excerpt) return '';
            
            return `<p class="blog-post-excerpt">${excerpt}</p>`;
        }

        // Shared function to generate publish date HTML structure - matches publish-date.njk macro
        function generatePublishDateHTML(date) {
            if (!date) return '';
            
            return `<p class="blog-post-date">
                <em>Published on 
                    <time datetime="${date}" data-pagefind-meta="date">
                        ${date}
                    </time>
                </em>
            </p>`;
        }

        // Shared function to generate category tags HTML structure - matches category-tags.njk macro
        function generateCategoryTagsHTML(categories) {
            if (!categories || categories.length === 0) return '';
            
            const categoryLinks = categories.map(category => {
                const categorySlug = category.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
                return `<a href="/blog/category/${categorySlug}/" class="category-tag">${category}</a>`;
            }).join('');
            
            return `<div class="blog-post-categories">${categoryLinks}</div>`;
        }

        // Shared function to extract categories from search results 
        function extractCleanCategories(originalTags, isBlogPost) {
            if (!originalTags || !isBlogPost) return [];
            
            const tagElements = originalTags.querySelectorAll('.pagefind-ui__result-tag');
            const categories = Array.from(tagElements).map(tag => tag.textContent.trim()).filter(tag => tag.length > 0);
            
            return categories;
        }

        // Shared function to generate blog card HTML structure - matches blog-card.njk macro
        function generateBlogCardHTML(data) {
            const { title, href, categories = [], excerpt = '', publishDate = '', isBlogPost = true } = data;
            
            let htmlContent = `
                <h2 class="blog-post-title">
                    <a href="${href}">${title}</a>
                </h2>
            `;
            
            // Add categories for blog posts using shared function
            if (isBlogPost && categories.length > 0) {
                htmlContent += generateCategoryTagsHTML(categories);
            }
            
            // Add excerpt using shared function
            if (excerpt) {
                htmlContent += generateBlogExcerptHTML(excerpt);
            }
            
            // Add publish date using shared function
            if (isBlogPost && publishDate) {
                htmlContent += generatePublishDateHTML(publishDate);
            }
            
            return htmlContent;
        }

        // Shared function to clean excerpts - matches the blogExcerpt filter behavior
        function cleanExcerpt(excerptText) {
            if (!excerptText) return '';
            
            let cleanExcerpt = excerptText
                // Remove "Published on..." prefixes
                .replace(/^.*?Published on.*?\d{4}\.?\s*/i, '')
                // Remove [code] blocks that haven't been processed yet
                .replace(/\[code[^\]]*\][\s\S]*?\[\/code\]/gi, ' ')
                // Remove generated code block HTML
                .replace(/<div class="code-block">[\s\S]*?<\/div>/gi, ' ')
                // Remove any remaining [code] orphan tags
                .replace(/\[(?:\/)?code[^\]]*\]/gi, ' ')
                // Remove HTML tags
                .replace(/<[^>]*>/g, ' ')
                // Remove code block indicators and language labels
                .replace(/\s*(COLDFUSION|JAVASCRIPT|HTML|CSS|SQL|JAVA|PHP|PYTHON|XML|JSON).*$/i, '')
                // Remove ColdFusion code patterns
                .replace(/<cf[^>]*>/gi, '')
                .replace(/<\/cf[^>]*>/gi, '')
                // Decode HTML entities (same order as blogExcerpt filter)
                .replace(/&quot;/g, '"')
                .replace(/&#39;/g, "'")
                .replace(/&apos;/g, "'")
                .replace(/&lt;/g, '<')
                .replace(/&gt;/g, '>')
                .replace(/&amp;/g, '&') // Keep this last to avoid double-decoding
                // Clean up whitespace
                .replace(/\s+/g, ' ')
                .trim();
            
            // If cleaning removed everything, use original but still clean it
            if (!cleanExcerpt || cleanExcerpt.length < 20) {
                cleanExcerpt = excerptText
                    .replace(/<[^>]*>/g, ' ')
                    .replace(/&[a-z]+;/gi, ' ')
                    .replace(/\s+/g, ' ')
                    .trim();
            }
            
            // Truncate to 300 characters to match blog list behavior
            if (cleanExcerpt.length > 300) {
                // Find the last complete word within the length limit (same logic as blogExcerpt)
                const truncated = cleanExcerpt.substring(0, 300);
                const lastSpace = truncated.lastIndexOf(' ');
                
                if (lastSpace > 300 * 0.8) {
                    // If we found a space reasonably close to the end
                    cleanExcerpt = truncated.substring(0, lastSpace) + '...';
                } else {
                    cleanExcerpt = truncated + '...';
                }
            }
            
            return cleanExcerpt;
        }

        // Process search results to match blog card structure and styling
        function processSearchResults() {
            const allResults = document.querySelectorAll('.pagefind-ui__result');
            const results = Array.from(allResults).filter(result => !result.hasAttribute('data-enhanced'));
            
            console.log('Processing ' + results.length + ' new search results');
            
            results.forEach(result => {
                const originalTitle = result.querySelector('.pagefind-ui__result-title');
                const originalExcerpt = result.querySelector('.pagefind-ui__result-excerpt');
                const originalUrl = result.querySelector('.pagefind-ui__result-link');
                const originalTags = result.querySelector('.pagefind-ui__result-tags');
                
                if (!originalTitle || !originalUrl) {
                    result.setAttribute('data-enhanced', 'true');
                    return;
                }

                // Extract basic data
                const titleText = originalTitle.textContent.trim();
                const excerptText = originalExcerpt ? originalExcerpt.textContent.trim() : '';
                let href = originalUrl.href;
                
                // Fix URL to use relative path
                if (href.includes('localhost:8080')) {
                    href = href.replace('http://localhost:8080', '');
                } else if (href.includes('localhost:')) {
                    href = href.replace(/http:\/\/localhost:\d+/, '');
                }
                
                const isBlogPost = href.includes('/blog/');
                
                // Extract categories using simple approach
                const categories = extractCleanCategories(originalTags, isBlogPost);
                
                // Extract date from URL pattern
                let publishDate = '';
                if (isBlogPost) {
                    const dateMatch = href.match(/\/(\d{4})-(\d{2})-(\d{2})-/);
                    if (dateMatch) {
                        const year = dateMatch[1];
                        const month = dateMatch[2]; 
                        const day = dateMatch[3];
                        const date = new Date(year, month - 1, day);
                        publishDate = date.toLocaleDateString('en-US', { 
                            year: 'numeric', 
                            month: 'long', 
                            day: 'numeric' 
                        });
                    }
                }
                
                // Default fallback for publish date
                if (isBlogPost && !publishDate) {
                    publishDate = 'March 2, 2008';
                }
                
                // Create new structure matching blog card format
                const newStructure = document.createElement('article');
                newStructure.className = isBlogPost ? 'blog-post-card' : 'search-result-page';
                
                // Use shared function to generate consistent HTML structure
                const cleanedExcerpt = cleanExcerpt(excerptText);
                const htmlContent = generateBlogCardHTML({
                    title: titleText,
                    href: href,
                    categories: categories,
                    excerpt: cleanedExcerpt,
                    publishDate: publishDate,
                    isBlogPost: isBlogPost
                });
                
                newStructure.innerHTML = htmlContent;
                
                // Add smooth entrance animation
                newStructure.style.opacity = '0';
                newStructure.style.transform = 'translateY(20px)';
                
                // Replace the original result with our new structure
                result.parentNode.replaceChild(newStructure, result);
                
                // Animate in after replacement
                setTimeout(() => {
                    newStructure.style.transition = 'all 0.4s ease-out';
                    newStructure.style.opacity = '1';
                    newStructure.style.transform = 'translateY(0)';
                }, 50 + Math.random() * 100);
                
                // Mark as enhanced to avoid duplicate processing
                newStructure.setAttribute('data-enhanced', 'true');
            });
        }

        // Initialize Pagefind Search if search element exists
        if (document.getElementById("search")) {
            try {
                // Auto-detect bundle path or use explicit path
                const bundlePath = window.location.pathname.includes('/search/') ? '../pagefind/' : '/pagefind/';
                
                const searchConfig = { 
                    element: "#search", 
                    showSubResults: true,
                    showEmptyFilters: false,
                    resetStyles: false,
                    autofocus: window.location.pathname.includes('/search/'),
                    debounceTimeoutMs: 300,
                    bundlePath: bundlePath,
                    excerptLength: 60,
                    pageSize: 8,
                    showImages: false,
                    translations: {
                        placeholder: "Search articles, posts, and pages...",
                        clear_search: "Clear",
                        load_more: "Load more results",
                        search_label: "Search this site",
                        filters_label: "Filters",
                        zero_results: "No results found for [SEARCH_TERM]",
                        many_results: "[COUNT] results for [SEARCH_TERM]",
                        one_result: "1 result for [SEARCH_TERM]",
                        alt_search: "No results for [SEARCH_TERM]. Showing results for [DIFFERENT_TERM] instead",
                        search_suggestion: "No results for [SEARCH_TERM]. Try one of the following searches:",
                        searching: "Searching for [SEARCH_TERM]..."
                    }
                };

                // Add custom result template for search page
                if (window.location.pathname.includes('/search/')) {
                    searchConfig.showImages = false;
                    searchConfig.showSubResults = true;
                    searchConfig.excerptLength = 80;
                    searchConfig.pageSize = 10;
                }
                
                const pagefindUI = new PagefindUI(searchConfig);
                
                // Process results after they load (works on any page with search)
                const searchElement = document.getElementById("search");
                if (searchElement) {
                    console.log('Setting up search results observer');
                    
                    let processingTimeout;
                    
                    // Single robust observer with debouncing
                    const observer = new MutationObserver((mutations) => {
                        let shouldProcess = false;
                        
                        mutations.forEach((mutation) => {
                            if (mutation.addedNodes.length > 0) {
                                // Check if search results were added
                                const hasResults = Array.from(mutation.addedNodes).some(node => 
                                    node.nodeType === 1 && 
                                    (node.classList && node.classList.contains('pagefind-ui__result') || 
                                     (node.querySelector && node.querySelector('.pagefind-ui__result')))
                                );
                                
                                if (hasResults) {
                                    shouldProcess = true;
                                }
                            }
                        });
                        
                        if (shouldProcess) {
                            console.log('New search results detected, scheduling processing...');
                            
                            // Clear any existing timeout to debounce rapid changes
                            if (processingTimeout) {
                                clearTimeout(processingTimeout);
                            }
                            
                            // Process after DOM has settled
                            processingTimeout = setTimeout(() => {
                                console.log('Processing search results...');
                                processSearchResults();
                            }, 100);
                        }
                    });
                    
                    observer.observe(searchElement, { 
                        childList: true, 
                        subtree: true 
                    });
                    
                    // Process any existing results that might have loaded before observer setup
                    setTimeout(() => processSearchResults(), 100);
                    const searchInput = searchElement.querySelector('input[type="search"]');
                    if (searchInput) {
                        searchInput.addEventListener('input', () => {
                            setTimeout(() => processSearchResults(), 400);
                            setTimeout(() => processSearchResults(), 800);
                        });
                    }
                }
                
                console.log('PagefindUI initialized successfully');
            } catch (error) {
                console.error('Failed to initialize PagefindUI:', error);
            }
        }

        // Enhanced Search Keyboard Shortcuts and Accessibility
        document.addEventListener('keydown', function(event) {
            // Ctrl/Cmd + K to focus search
            if ((event.ctrlKey || event.metaKey) && event.key === 'k') {
                event.preventDefault();
                const searchInput = document.querySelector('.pagefind-ui__search-input');
                if (searchInput) {
                    searchInput.focus();
                    searchInput.select();
                }
            }
            
            // Escape to clear search when input is focused
            if (event.key === 'Escape') {
                const searchInput = document.querySelector('.pagefind-ui__search-input');
                if (searchInput && document.activeElement === searchInput) {
                    searchInput.value = '';
                    searchInput.dispatchEvent(new Event('input', { bubbles: true }));
                }
            }
        });
        
        // Add search shortcut hint
        const searchInput = document.querySelector('.pagefind-ui__search-input');
        if (searchInput && window.location.pathname.includes('/search/')) {
            searchInput.setAttribute('title', 'Use Ctrl+K to focus search, Escape to clear');
            
            // Add subtle hint after the search loads
            setTimeout(() => {
                const searchContainer = document.getElementById('search');
                if (searchContainer && !searchContainer.querySelector('.search-hint')) {
                    const hint = document.createElement('p');
                    hint.className = 'search-hint';
                    hint.style.cssText = `
                        text-align: center; 
                        color: var(--color-text-secondary); 
                        font-size: var(--font-size-xs); 
                        margin-top: var(--spacing-sm);
                        opacity: 0.7;
                    `;
                    hint.innerHTML = '<kbd style="background: var(--color-surface-light); padding: 2px 6px; border-radius: 3px; font-size: 11px;">Ctrl+K</kbd> to focus â€¢ <kbd style="background: var(--color-surface-light); padding: 2px 6px; border-radius: 3px; font-size: 11px;">Esc</kbd> to clear';
                    searchContainer.appendChild(hint);
                }
            }, 1000);
        }

        // Animated Progress Bars - Intersection Observer
        const progressBars = document.querySelectorAll('.progress-bar[data-width]');
        
        if (progressBars.length > 0) {
            const animateProgressBar = (progressBar) => {
                const targetWidth = progressBar.getAttribute('data-width');
                const span = progressBar.querySelector('span');
                
                if (span && targetWidth) {
                    // Add animate class to enable transitions
                    progressBar.classList.add('animate');
                    
                    // Set the CSS custom property and animate
                    progressBar.style.setProperty('--progress-width', targetWidth + '%');
                    
                    // Set the target width after a small delay to trigger animation
                    setTimeout(() => {
                        span.style.width = targetWidth + '%';
                    }, 50);
                }
            };

            // Check if Intersection Observer is supported
            if ('IntersectionObserver' in window) {
                const observerOptions = {
                    root: null,
                    rootMargin: '0px 0px -10% 0px', // Trigger when 90% visible
                    threshold: 0.1
                };

                const observer = new IntersectionObserver((entries) => {
                    entries.forEach((entry) => {
                        if (entry.isIntersecting && !entry.target.classList.contains('animate')) {
                            animateProgressBar(entry.target);
                            // Stop observing this element once animated
                            observer.unobserve(entry.target);
                        }
                    });
                }, observerOptions);

                // Start observing all progress bars
                progressBars.forEach((progressBar) => {
                    observer.observe(progressBar);
                });
            } else {
                // Fallback: animate immediately if Intersection Observer not supported
                progressBars.forEach((progressBar) => {
                    animateProgressBar(progressBar);
                });
            }
        }

        // Animated Methodology Items - Intersection Observer
        const methodologyItems = document.querySelectorAll('.methodology-item[data-animation-delay]');
        
        if (methodologyItems.length > 0) {
            const animateMethodologyItem = (item) => {
                const delay = item.getAttribute('data-animation-delay') || '0s';
                item.style.setProperty('--animation-delay', delay);
                item.classList.add('animate');
            };

            // Check if Intersection Observer is supported
            if ('IntersectionObserver' in window) {
                const observerOptions = {
                    root: null,
                    rootMargin: '0px 0px -10% 0px', // Trigger when 90% visible
                    threshold: 0.1
                };

                const methodologyObserver = new IntersectionObserver((entries) => {
                    entries.forEach((entry) => {
                        if (entry.isIntersecting && !entry.target.classList.contains('animate')) {
                            animateMethodologyItem(entry.target);
                            // Stop observing this element once animated
                            methodologyObserver.unobserve(entry.target);
                        }
                    });
                }, observerOptions);

                // Start observing all methodology items
                methodologyItems.forEach((item) => {
                    methodologyObserver.observe(item);
                });
            } else {
                // Fallback: animate immediately if Intersection Observer not supported
                methodologyItems.forEach((item) => {
                    animateMethodologyItem(item);
                });
            }
        }

        // Animated Framework Items - Intersection Observer
        const frameworkItems = document.querySelectorAll('.framework-item[data-animation-delay]');
        
        if (frameworkItems.length > 0) {
            const animateFrameworkItem = (item) => {
                const delay = item.getAttribute('data-animation-delay') || '0s';
                item.style.setProperty('--animation-delay', delay);
                item.classList.add('animate');
            };

            // Check if Intersection Observer is supported
            if ('IntersectionObserver' in window) {
                const observerOptions = {
                    root: null,
                    rootMargin: '0px 0px -10% 0px', // Trigger when 90% visible
                    threshold: 0.1
                };

                const frameworkObserver = new IntersectionObserver((entries) => {
                    entries.forEach((entry) => {
                        if (entry.isIntersecting && !entry.target.classList.contains('animate')) {
                            animateFrameworkItem(entry.target);
                            // Stop observing this element once animated
                            frameworkObserver.unobserve(entry.target);
                        }
                    });
                }, observerOptions);

                // Start observing all framework items
                frameworkItems.forEach((item) => {
                    frameworkObserver.observe(item);
                });
            } else {
                // Fallback: animate immediately if Intersection Observer not supported
                frameworkItems.forEach((item) => {
                    animateFrameworkItem(item);
                });
            }
        }
    });

    // Copy code functionality for code blocks - Global functions
    window.copyCode = function(button) {
        const codeBlock = button.closest('.code-block');
        if (!codeBlock) return;
        
        const code = codeBlock.querySelector('code');
        if (!code) return;
        
        const textToCopy = code.textContent;
        
        // Use the modern clipboard API if available
        if (navigator.clipboard && window.isSecureContext) {
            navigator.clipboard.writeText(textToCopy).then(() => {
                window.showCopySuccess(button);
            }).catch(err => {
                console.error('Failed to copy code: ', err);
                window.fallbackCopyCode(textToCopy, button);
            });
        } else {
            // Fallback for older browsers
            window.fallbackCopyCode(textToCopy, button);
        }
    };
    
    // Fallback copy method for older browsers
    window.fallbackCopyCode = function(text, button) {
        const textArea = document.createElement('textarea');
        textArea.value = text;
        textArea.style.position = 'fixed';
        textArea.style.left = '-999999px';
        textArea.style.top = '-999999px';
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();
        
        try {
            document.execCommand('copy');
            window.showCopySuccess(button);
        } catch (err) {
            console.error('Failed to copy code: ', err);
        } finally {
            document.body.removeChild(textArea);
        }
    };
    
    // Show copy success feedback
    window.showCopySuccess = function(button) {
        const originalIcon = button.innerHTML;
        button.innerHTML = '<i class="fas fa-check"></i>';
        button.classList.add('copy-success');
        
        setTimeout(() => {
            button.innerHTML = originalIcon;
            button.classList.remove('copy-success');
        }, 2000);
    };
</script>

<!-- PrismJS syntax highlighting scripts -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.js"></script>
<script>
    // Initialize PrismJS after DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
        // Configure PrismJS autoloader
        if (typeof Prism !== 'undefined') {
            Prism.plugins.autoloader.languages_path = 'https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/';
            
            // Add language aliases and custom ColdFusion support
            if (Prism.languages) {
                // Create a better ColdFusion language definition
                Prism.languages.coldfusion = Prism.languages.extend('markup', {
                    'cf-tag': {
                        pattern: new RegExp('<\\/?cf[a-z]+(?:\\s[^>]*)?\\/?>', 'i'),
                        inside: {
                            'tag': {
                                pattern: new RegExp('<\\/?cf[a-z]+', 'i'),
                                inside: {
                                    'punctuation': /^<\/?/,
                                    'namespace': /^cf/
                                }
                            },
                            'attr-name': {
                                pattern: new RegExp('(?:[a-z]|-)+(?=\\s*=)', 'i')
                            },
                            'attr-value': {
                                pattern: new RegExp('=\\s*(?:"[^"]*"|\'[^\']*\'|[^\\s>]+)', 'i'),
                                inside: {
                                    'punctuation': [/^=/, new RegExp('^[\'"]|[\'"]$')]
                                }
                            },
                            'punctuation': /\/?>/
                        }
                    },
                    'cf-script': {
                        pattern: new RegExp('#[^#]*#', ''),
                        inside: {
                            'punctuation': /^#|#$/,
                            'keyword': /\b(?:var|if|else|elseif|for|while|function|return|true|false|null)\b/i,
                            'string': {
                                pattern: new RegExp('("|\')\(?:\\\\.|(?!\\1)[^\\\\\\r\\n]\)*\\1', '')
                            },
                            'number': {
                                pattern: new RegExp('\\b0x[\\da-f]+\\b|(?:\\b\\d+\\.?\\d*|\\B\\.\\d+)(?:e[+-]?\\d+)?', 'i')
                            },
                            'operator': {
                                pattern: new RegExp('[<>]=?|[!=]=?=?|--?|\\+\\+?|&&?|\\|\\|?|[?*/~^%]')
                            },
                            'punctuation': {
                                pattern: new RegExp('[{}\\[\\];(),.:]+')
                            }
                        }
                    },
                    'cf-function': {
                        pattern: new RegExp('\\b[a-zA-Z_]\\w*(?=\\s*\\()', ''),
                        alias: 'function'
                    }
                });
                
                // Map other CFML variations
                Prism.languages.cfml = Prism.languages.coldfusion;
                Prism.languages.cfscript = Prism.languages.javascript;
            }
        }
    });
</script>
